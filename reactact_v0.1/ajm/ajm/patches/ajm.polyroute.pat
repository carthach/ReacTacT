max v2;#N vpatcher 186 280 921 771;#P window setfont "Sans Serif" 9.;#P window linecount 1;#P newex 99 120 20 196617 t b;#P newex 112 152 36 196617 zl reg;#P objectname zl-reg;#P newex 75 98 66 196617 regexp /.*;#P newex 10 79 27 196617 t l b;#P message 27 115 47 196617 target 0;#P newex 10 56 50 196617 route /*;#P newex 464 48 73 196617 patcherargs 4;#P newex 31 342 30 196617 t b s;#P newex 63 372 36 196617 zl reg;#P message 31 320 53 196617 target \$1;#P newex 48 290 51 196617 zl slice 1;#P objectname zl-slice;#P inlet 10 27 15 0;#P outlet 51 422 15 0;#P objectname outlet;#P newex 464 74 130 196617 js ajm.polyroute-helper.js;#P window linecount 3;#P comment 240 342 249 196617 NOTE: When editing this patch \, you need to delete the OSC-route (/1 /2 /3 /4 ...) and prepends (1 \, 2 \, ...) created automatically by patcherargs before saving!!;#P window linecount 2;#P comment 66 53 313 196617 Intercept /* early and send "target 0" \, "msg. Otherwise OSC-route will send target" 1 \, msg ... target n \, "msg which is less efficient";#P window linecount 6;#P comment 151 96 276 196617 Only pass messages starting with a "/" to the OSC-route. regexp "corrupts" the message by turning it into a single symbol. We could try to use the fromsymbol object to "uncorrupt" the message \, but this doesn't work in all cases (for example if the message is "1\\\,2" the comma will disappear). So zl reg is used instead.;#P connect 5 0 11 0;#P connect 11 0 13 0;#P connect 13 1 12 0;#P connect 6 0 7 0;#P connect 7 0 9 0;#P connect 9 1 4 0;#P connect 8 0 4 0;#P fasten 12 0 4 0 32 138 15 138 15 411 56 411;#P fasten 13 0 4 0 15 411 56 411;#P fasten 14 3 4 0 122 145 15 145 15 411 56 411;#P connect 9 0 8 0;#P connect 11 1 14 0;#P connect 6 1 8 1;#P connect 14 2 16 0;#P connect 16 0 15 0;#P fasten 11 1 15 1 55 90 143 90;#P connect 10 0 3 0;#P pop;